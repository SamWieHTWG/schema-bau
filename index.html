<!DOCTYPE html>
<html lang="en">

  <head>
    <!-- Bootstrap 4 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <title>three.js webgl - postprocessing - unreal bloom selective</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      html {
       cursor: url('cursor2.png'), auto;
}

      body {
        margin: 0;
      }

      canvas {
        display: block;
      }

      #meinButton {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        /* Stellt sicher, dass der Button über dem Canvas liegt */
      }
    </style>
  </head>

  <body>
    <script type="x-shader/x-vertex" id="vertexshader">

      varying vec2 vUv;

      void main() {

      	vUv = uv;

      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;

      varying vec2 vUv;

      void main() {

      	gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

      }
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.min.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

      const BLOOM_SCENE = 1;

      const bloomLayer = new THREE.Layers();
      bloomLayer.set(BLOOM_SCENE);

      const params = {
        threshold: 0,
        strength: 1,
        radius: 0.5,
        exposure: 1,
      };

      const darkMaterial = new THREE.MeshBasicMaterial({ color: "black" });
      const materials = {};

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ReinhardToneMapping;

      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        40,
        window.innerWidth / window.innerHeight,
        1,
        200
      );

      // OrbitControls initialisieren
      const controls = new OrbitControls(camera, renderer.domElement);
       controls.target.set(0, 0, 0); // Zielpunkt der Kamera

      // Berechnen des Zentrums und der Größe der Szene
      const box = new THREE.Box3().setFromObject(scene);
      var center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      var maxX = 10; // Math.max.apply(Math, points.x);
      var maxY = 10; // Math.max.apply(Math, points.y);
      var maxZ = 10; // Math.max.apply(Math, points.z);

      // Positionieren der Kamera für eine seitliche schräge Ansicht
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      const cameraZ = Math.abs((maxDim / 4) * Math.tan(fov * 2)); // Geringerer Abstand für eine engere Ansicht

      var fact = 1.1;
      camera.position.x = center.x - maxX * fact;
      camera.position.y = center.y;
      camera.position.z = center.z;

      // Die Kamera sollte auf das Zentrum der Szene ausgerichtet sein
      camera.lookAt(center);

      scene.background = new THREE.Color(0xf5f5f5); // Sets the background to white

      const renderScene = new RenderPass(scene, camera);
      const composer = new EffectComposer(renderer);
      composer.addPass(renderScene);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      window.addEventListener("pointerdown", onPointerDown);

      function onPointerDown(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, false);
        if (intersects.length > 0) {
          const object = intersects[0].object;
          object.layers.toggle(BLOOM_SCENE);
          render();
        }
      }

      window.onresize = function () {
        const width = window.innerWidth;
        const height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);

        bloomComposer.setSize(width, height);
        finalComposer.setSize(width, height);

        render();
      };

      var sinXIdx = [];
      var sinYIdx = [];
      var sinZIdx = [];
      var sinusOffset = [];

      var particles;
      const particleCount = 5;
      var particleSetIdx = [];
      var particleIdx = [];
      var particleSpeed = [];
      var particleStartPos = [];
      var particleEndPos = [];

        var particleMeshs = [];

        var partPos = [];


      var linePoints = [];

      function createOrder(L) {
        // Calculate the half-length to position vertices from the center
        const halfL = L / 2;

        // Define vertices of the cube
        const vertices = [
          new THREE.Vector3(-halfL, -halfL, halfL), // Vertex 0
          new THREE.Vector3(halfL, -halfL, halfL), // Vertex 1
          new THREE.Vector3(halfL, halfL, halfL), // Vertex 2
          new THREE.Vector3(-halfL, halfL, halfL), // Vertex 3
          new THREE.Vector3(-halfL, -halfL, -halfL), // Vertex 4
          new THREE.Vector3(halfL, -halfL, -halfL), // Vertex 5
          new THREE.Vector3(halfL, halfL, -halfL), // Vertex 6
          new THREE.Vector3(-halfL, halfL, -halfL), // Vertex 7
        ];

        // Define a path as an array of line segments (pairs of vertices)
        const path = [
          [vertices[0], vertices[1]],
          [vertices[1], vertices[2]],
          [vertices[2], vertices[3]],
          [vertices[3], vertices[0]], // Top face loop
          [vertices[0], vertices[4]],
          [vertices[4], vertices[5]],
          [vertices[5], vertices[6]],
          [vertices[6], vertices[7]], // Vertical edges connecting top to bottom
          [vertices[7], vertices[3]],
          [vertices[3], vertices[2]],
          [vertices[2], vertices[1]],
          [vertices[1], vertices[0]], // Bottom face loop
        ];

        // Function to simulate drawing this path (you would replace this with your own rendering logic)
        return path;
      }

      function setupScene() {
        scene.traverse(disposeMaterial);
        scene.children.length = 0;

        const material = new THREE.LineBasicMaterial({ color: "black" });

        const geometry = new THREE.BoxGeometry(5, 5, 5); // Width, Height, Depth
        var edges = new THREE.EdgesGeometry(geometry); // Get edges from the geometry

        // Extract vertices
        const vertices = edges.attributes.position.array;

        // Format the vertices into the desired structure
        var edgePoints = { x: [], y: [], z: [] };
        for (let i = 0; i < vertices.length; i += 3) {
          edgePoints.x.push(vertices[i]);
          edgePoints.y.push(vertices[i + 1]);
          edgePoints.z.push(vertices[i + 2]);
        }
        edgePoints = [edgePoints];

        // Load a font and create text
        const loader = new FontLoader();
        loader.load("font4.json", function (font) {
          const textGeometry = new TextGeometry("{ }", {
            // Replace 'Hello!' with your text
            size: 0.5,
            depth: 0.000001,
            curveSegments: 12,
            font: font,
          });
          // const textMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const textMesh = new THREE.Mesh(textGeometry, material);
          textMesh.position.set(-2, -2, -2.5); // Adjust position as needed
          scene.add(textMesh);
        });

        for (let j = 0; j < edgePoints.length; j++) {
          var pointsData = edgePoints[j];
          var set = [];

          for (let i = 0; i < pointsData.x.length; i++) {
            set.push(
              new THREE.Vector3(
                pointsData.x[i],
                pointsData.y[i],
                pointsData.z[i]
              )
            );
          }
          // Close the loop by adding the first point at the end if necessary
          set.push(
            new THREE.Vector3(pointsData.x[0], pointsData.y[0], pointsData.z[0])
          );

          // Now check for axis-aligned segments
          for (let i = 0; i < set.length - 1; i++) {
            const pointA = set[i];
            const pointB = set[i + 1];

            // Check if the line is parallel to any axis
            if (
              (pointA.x === pointB.x && pointA.y === pointB.y) || // Parallel to Z
              (pointA.y === pointB.y && pointA.z === pointB.z) || // Parallel to X
              (pointA.x === pointB.x && pointA.z === pointB.z)
            ) {
              // Parallel to Y
              // Create a geometry for each axis-aligned segment
              const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                pointA,
                pointB,
              ]);
              const material = new THREE.LineBasicMaterial({ color: "black" }); // White line
              const line = new THREE.Line(lineGeometry, material);
              scene.add(line);
              linePoints.push([pointA, pointB]);
            }
          }
        }

        linePoints = createOrder(5);
        for (var idx = 0; idx < linePoints.length; idx++) {
        //   console.log(linePoints[idx][0], linePoints[idx][1]);
          if (idx > 0) {
            if (linePoints[idx][0] != linePoints[idx - 1][1]) {
              var stop = 1;
            }
          }
        }

        // Erstellen der Partikel-Geometrie
        const particlePositions = new Float32Array(particleCount * 3);
        // const particleGeometry = new THREE.BufferGeometry();
        const particleSize = 0.15
        const particleGeometry = new THREE.BoxGeometry(particleSize,particleSize,particleSize); // Size of each cube
        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); 
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 }); // Color of edges
        edges = new THREE.EdgesGeometry(particleGeometry);


        for (let i = 0; i < particleCount; i++) {
          // Partikel initial zufällig entlang der Linie verteilen
          let t = Math.random();
          var setIndex = Math.floor(t * (linePoints.length - 1));
          particleStartPos[i] = linePoints[setIndex][0];
          particleEndPos[i] = linePoints[setIndex][1];
          particleSpeed[i] = Math.random() * 0.1 + 0.05;

        //   let pointStart = linePoints[setIndex][index];
          let x =  particleStartPos[i].x 
          let y =  particleStartPos[i].y 
          let z =  particleStartPos[i].z 

          particlePositions[i * 3] = x;
          particlePositions[i * 3 + 1] = y;
          particlePositions[i * 3 + 2] = z;
        //   const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
          const particleMesh = new THREE.LineSegments(edges, edgeMaterial);
          particleMesh.position.x = x;
          particleMesh.position.y = y;
          particleMesh.position.z = z;
          scene.add(particleMesh);
          particleMeshs.push(particleMesh)
        }

        // // Erstellen des Materials für die Partikel
        // const particleMaterial = new THREE.PointsMaterial({
        //   color: "black",
        // //   size: 0.5,
        //   // blending: THREE.AdditiveBlending,
        //   depthTest: false,
        //   transparent: true,
        // });

        // Erstellen der Partikel-Points und zur Szene hinzufügen
        // particles = new THREE.Points(particleGeometry, particleMaterial);

        render();
      }

      function disposeMaterial(obj) {
        if (obj.material) {
          obj.material.dispose();
        }
      }

      function render() {
        composer.render();
        // scene.traverse(darkenNonBloomed);
        // scene.traverse(restoreMaterial);

        // render the entire scene, then render bloom scene on top
        // finalComposer.render();
      }

      function darkenNonBloomed(obj) {
        if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
          materials[obj.uuid] = obj.material;
          obj.material = darkMaterial;
        }
      }

      function restoreMaterial(obj) {
        if (materials[obj.uuid]) {
          obj.material = materials[obj.uuid];
          delete materials[obj.uuid];
        }
      }

      function calculateSphericalCoordinates(center, point) {
        // Destructure the center and point coordinates
        var x_m = center.x;
        var y_m = center.y;
        var z_m = center.z;
        var x = point[0];
        var y = point[1];
        var z = point[2];

        // Translate point to the origin based on the center
        const x_prime = x - x_m;
        const y_prime = y - y_m;
        const z_prime = z - z_m;

        // Calculate the spherical coordinates
        const r = Math.sqrt(
          x_prime * x_prime + y_prime * y_prime + z_prime * z_prime
        );
        var theta = Math.acos(z_prime / r);
        var phi = Math.atan2(y_prime, x_prime);

        // Return the spherical coordinates
        return { r, theta, phi };
      }

      function calculateRotation(center, point, dt) {
        // Destructure the center and point coordinates
        var x_m = center.x;
        var y_m = center.y;
        var z_m = center.z;
        var x = point[0];
        var y = point[1];
        var z = point[2];

        // Translate point to the origin based on the center
        const x_prime = x - x_m;
        const y_prime = y - y_m;
        const z_prime = z - z_m;

        // Example Quaternion
        const quaternion = new THREE.Quaternion();
        quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0.1 * dt); // Rotate around Y-axis by 45 degrees

        // Create a Vector3 from the coordinates
        let vector = new THREE.Vector3(x_prime, y_prime, z_prime);

        // Apply the quaternion to the vector
        vector.applyQuaternion(quaternion);

        vector.x = center.x + vector.x;
        vector.y = center.y + vector.y;
        vector.z = center.z + vector.z;
        return vector;
      }

      function sphericalToCartesian(r, theta, phi) {
        // Stelle sicher, dass Theta und Phi in Radiant sind
        const x = r * Math.sin(theta) * Math.cos(phi);
        const y = r * Math.sin(theta) * Math.sin(phi);
        const z = r * Math.cos(theta);

        return { x, y, z };
      }

      function quaternionToCartesian(r, quaternion) {
        // Unit vector along the z-axis (as if theta = 0 and phi = 0)
        const unitVector = new THREE.Vector3(0, 0, 1);

        // Apply the quaternion rotation to the unit vector
        unitVector.applyQuaternion(quaternion);

        // Scale the vector by radius r
        const x = unitVector.x * r;
        const y = unitVector.y * r;
        const z = unitVector.z * r;

        return { x, y, z };
      }

      function calculate3DDistance(p1, p2) {
        let x1 = p1.x;
        let y1 = p1.y;
        let z1 = p1.z;
        let x2 = p2.x;
        let y2 = p2.y;
        let z2 = p2.z;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const dz = z2 - z1;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      }

      var time_last = Date.now();

      var mouseIsMoving = false;
      var mousePosX;
      var mousePosY;
      function animate() {
        const time = Date.now() * 0.001; // Zeit in Sekunden
        var dt = time - time_last;
        if (Math.abs(dt) > 1) dt = 0;
        time_last = time;

        var pos = [camera.position.x, camera.position.y, camera.position.z];
        var polar = calculateSphericalCoordinates(center, pos);
        var vector = calculateRotation(center, pos, dt);

        polar.phi = polar.phi + dt * 0.5;

        // console.log(polar.theta)
        // polar.phi = polar.phi + dt * 0.02;
        // console.log(polar.theta)
        // var vals = sphericalToCartesian(polar.r, polar.theta, polar.phi)
        // var vals = quaternionToCartesian(polar.r,q)
        // Kamerabewegung aktualisieren
        camera.position.x = vector.x;
        camera.position.y = vector.y;
        camera.position.z = vector.z;

        // Die Kamera sollte auf das Zentrum der Szene ausgerichtet sein
        camera.lookAt(center);

        // Partikel entlang der Linie animieren
        // let partPos = particles.geometry.attributes.position.array;

        for (let i = 0; i < particleCount; i++) {

          partPos[i*3] = particleMeshs[i].position.x;
          partPos[i*3 + 1] = particleMeshs[i].position.y;
          partPos[i*3 + 2] = particleMeshs[i].position.z;

          let t = (Date.now() % 10000) / 100000;
          var pos = {
            x: partPos[i * 3],
            y: partPos[i * 3 + 1],
            z: partPos[i * 3 + 2],
          };
          // let index = Math.floor(t * (linePoints.length - 1));
          var idx = particleIdx[i];
          // let pointStart = linePoints[idx];
          //   var set = linePoints[particleSetIdx[i]];

          let linePosEnd = particleEndPos[i]; // set[1];
          var pointEnd = { x: linePosEnd.x, y: linePosEnd.y, z: linePosEnd.z };

          let pointStart = pos;

          if (mouseIsMoving) {
            var pointEnd = { x: 0, y: 30, z: 0 };
          }

          var interp = 0.2 * particleSpeed[i];

          try {
            var lengthToEnd = calculate3DDistance(pos, pointEnd);
          } catch {
            stop = 1;
            lengthToEnd = 0;
          }
          if (interp >= lengthToEnd) {
            interp = lengthToEnd;
            // find point that is connected to linePointEnd
            var connectedLines = [];
            for (var idx = 0; idx < linePoints.length; idx++) {
              if (linePoints[idx][0] == linePosEnd) {
                connectedLines.push(linePoints[idx]);
              }
              if (linePoints[idx][1] == linePosEnd) {
                connectedLines.push([linePoints[idx][1], linePoints[idx][0]]);
              }
            }
            function getRandomElement(arr) {
              if (arr.length === 0) {
                return null; // Return null if the array is empty
              }
              const randomIndex = Math.floor(Math.random() * arr.length);
              return arr[randomIndex];
            }
            var randEL = getRandomElement(connectedLines);
            particleEndPos[i] = randEL[1];

            partPos[i * 3]     = randEL[0].x
            partPos[i * 3 + 1] = randEL[0].y
            partPos[i * 3 + 2] = randEL[0].z
          }

          var interpLength = Math.sqrt(
            (pointEnd.x - pointStart.x) ** 2 +
              (pointEnd.y - pointStart.y) ** 2 +
              (pointEnd.z - pointStart.z) ** 2
          );
          if (interpLength == 0) continue;

          var dirX = (pointEnd.x - pointStart.x) / interpLength;
          var dirY = (pointEnd.y - pointStart.y) / interpLength;
          var dirZ = (pointEnd.z - pointStart.z) / interpLength;

          partPos[i * 3] = pos.x + dirX * interp;
          partPos[i * 3 + 1] = pos.y + dirY * interp;
          partPos[i * 3 + 2] = pos.z + dirZ * interp;
          // console.log(positions)

          particleMeshs[i].position.x =  partPos[i*3 + 0];
          particleMeshs[i].position.y =  partPos[i*3 + 1];
          particleMeshs[i].position.z =  partPos[i*3 + 2];
        }

        requestAnimationFrame(animate);

        var idx = 0;
        scene.children.forEach((obj) => {
          var stop = 1;
          if (obj.isMesh && false) {
            // Einfache Anpassung für wellenartige Bewegung
            var offset =
              Math.sin(sinusOffset[idx] + time + obj.position.x * 0.5) * 0.1;
            if (sinXIdx[idx] == -1) {
              offset = offset * -1;
            }
            obj.position.x = points.x[idx] + offset;

            // Einfache Anpassung für wellenartige Bewegung
            var offset =
              Math.sin(sinusOffset[idx] + time + obj.position.y * 0.5) * 0.05;
            if (sinYIdx[idx] == -1) {
              offset = offset * -1;
            }
            obj.position.y = points.y[idx] + offset;

            // Einfache Anpassung für wellenartige Bewegung
            var offset =
              Math.sin(sinusOffset[idx] + time + obj.position.z * 0.5) * 0.05;
            if (sinYIdx[idx] == -1) {
              offset = offset * -1;
            }
            obj.position.z = points.z[idx] + offset;

            if (Math.random() < 0.25) {
              // obj.layers.enable(BLOOM_SCENE);
            }
          }
          idx = idx + 1;
        });
        // bloomPass.strength = 1.5 + Math.sin(time) * 0.5; // Basisstärke + wellenartige Variation
        render();
      }

      setupScene();

      animate(); // Starten der Animation

      var timeoutId;

      function handleMouseMove(event) {
        // Setze den Timer zurück, wenn sich die Maus bewegt
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
        }
        // mouseIsMoving = true;

        mousePosX = event.clientX;
        mousePosY = event.clientY;
        // Starte den Timer neu
        timeoutId = setTimeout(() => {
          // console.log('Mausbewegung gestoppt');
          mouseIsMoving = false;
        }, 100); // Verzögerung von 1000 Millisekunden (1 Sekunde)

        // console.log("Mausposition - X:", event.clientX, "Y:", event.clientY);
      }

      // Füge den Event-Listener zum window-Objekt hinzu
      window.addEventListener("mousemove", handleMouseMove);
    </script>
  </body>
</html>
