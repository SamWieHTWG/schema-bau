<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Bootstrap 4 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <title>three.js webgl - postprocessing - unreal bloom selective</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      html {
        cursor: url("cursor2.png"), auto;
      }

      body {
        margin: 0;
      }

      canvas {
        display: block;
      }

      #meinButton {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        /* Stellt sicher, dass der Button über dem Canvas liegt */
      }
    </style>
  </head>

  <body>
    <script type="x-shader/x-vertex" id="vertexshader">

      varying vec2 vUv;

      void main() {

      	vUv = uv;

      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;

      varying vec2 vUv;

      void main() {

      	gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

      }
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.min.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { SVGLoader } from "three/addons/loaders/SVGLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

      const WindowWidth =  window.innerWidth
      const WindowhHeigth =  window.innerHeight
      let scene, camera, renderer, circle, arrow;
      let arrowLength = 100,
        speed = 0.08;

      var lineStart1 = -arrowLength / 2;
      var lineEnd1 = arrowLength / 2;

      var lineStart2 = arrowLength / 2 + arrowLength / 5;
      var lineEnd2 = lineStart2 + arrowLength;

      var line1Mid = (lineStart1 + lineEnd1) / 2;
      var line2Mid = (lineStart2 + lineEnd2) / 2;

      var lines = [];
      lines.push({ start: lineStart1, end: lineEnd1 });
      lines.push({ start: lineStart2, end: lineEnd2 });

      var texts = [];
      // Adding each text entry
      addText("Inkraft", 8, 2024);
      addText("Veroeffentlichung", 11, 2024);
      addText("Harmon", 4, 2025);
      addText("Verpflicht", 9, 2025);
      addText("System", 5, 2026);
      addText("Schritt", 6, 2027);
      addText("Imple", 7, 2027);
      addText("DPPVerpf", 4, 2028);
      addText("Ökoricht", 10, 2028);

      var years = ["2025", "2026", "2027", "2028", "2029"];

      var MARKERSIZE = 0.002 * 100;
      var MARKERLENGTH = 0.1 * 100;
      var MARKERSIZEYEAR = 0.001 * 100;
      var MARKERLENGTHYEAR = 0.05 * 100;
      var YEARHEIGHT = 5;
      var YEARWIDTH = 10;
      var size = 5;
      var TEXTHEIGTH = WindowWidth *0.01;
      var TEXTWIDTH =WindowWidth*0.01;

      scene = new THREE.Scene();

      renderer = new THREE.WebGLRenderer();
      renderer.setSize(WindowWidth, WindowhHeigth);
      renderer.setClearColor(0xf5f5f5); // Set background color to grey
      document.body.appendChild(renderer.domElement);

      // Create a black circle
      // const circleGeometry = new THREE.CircleGeometry(0.01 * 100, 100);
      // const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black color
      // circle = new THREE.Mesh(circleGeometry, circleMaterial);
      // circle.position.x = lineStart;
      // scene.add(circle);
      var lineStart;
      var lineEnd;
      for (var lineIdx = 0; lineIdx < lines.length; lineIdx = lineIdx + 1) {
        lineStart = lines[lineIdx].start;
        lineEnd = lines[lineIdx].end;
        // Create a black line
        {
          const points = [];
          points.push(new THREE.Vector3(lineStart, 0, 0));
          points.push(new THREE.Vector3(lineEnd, 0, 0));
          const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
          const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
          var line = new THREE.Line(lineGeometry, lineMaterial);
          scene.add(line);
        }

        // Add a vertical marker at the beginning of the timeline
        const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

        for (var idx = 0; idx < years.length; idx = idx + 1) {
          var year = years[idx];
          var path = "svgs/" + year + ".svg";
          const markerGeometry = new THREE.BoxGeometry(
            MARKERSIZEYEAR,
            MARKERLENGTHYEAR,
            0
          ); // Thin vertical line
          const marker = new THREE.Mesh(markerGeometry, markerMaterial);
          var markerPos = calcPosFromDate(1, parseInt(year, 10));
          marker.position.set(markerPos, 0, 0);
          scene.add(marker);
          addSVGtoScene(
            path,
            YEARWIDTH,
            YEARHEIGHT,
            markerPos,
            MARKERLENGTHYEAR / 2 + YEARHEIGHT / 2,
            0
          );
        }

        let svgMeshes = [];

        // Add a vertical marker at the beginning of the timeline
        var pos;

        var dir = -1;
        for (var idx = 0; idx < texts.length; idx = idx + 1) {
          var text = texts[idx];
          dir = dir * -1;
          var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
          var m = new THREE.Mesh(geo, markerMaterial);
          pos = calcPosFromDate(text["month"], text["year"]);
          m.position.set(pos, (dir * MARKERLENGTH) / 2, 0);
          scene.add(m);
          var path = "svgs/" + text["path"] + ".svg";
          addSVGtoScene(
            path,
            TEXTWIDTH,
            TEXTHEIGTH,
            pos,
            dir * (MARKERLENGTH + TEXTHEIGTH / 2),
            0
          );
        }
      }

      var cameraLenght = 0.6 * arrowLength;

      lineStart = lines[1].start;
      lineEnd = lines[1].end;;
      var  pos = calcPosFromDate(8,2025);
      camera = new THREE.PerspectiveCamera(); //cameraLenght, 0.5, 1, 1000 );
      camera.position.set(pos, 0, WindowWidth / 10 );
      camera.lookAt(pos, 0, 0);

      function animate() {
        requestAnimationFrame(animate);

        // Move the circle along the arrow
        camera.position.x += speed;
        if (camera.position.x > line2Mid) {
          camera.position.x = line1Mid
        }
        // if (circle.position.x > lineEnd)
        // Reset to start once end is reached
        // circle.position.x = lineStart;
        renderer.render(scene, camera);
        size += 0.1;
        // if (svgMeshes[0]) {
        // updateSVG(svgMeshes[0], 10+size, 10+size, 0, 0, 0);
        // }
        // updateTextSize("2025", size);
      }

      animate();

      function calcPosFromDate(month, year) {
        // Set the start date to October 1, 2024
        const startDate = new Date(2024, 5, 1); // Month is 0-indexed (9 is October)
        const endDate = new Date(2029, 2, 31); // Month is 0-indexed (11 is December)
        const diffTimeAll = endDate - startDate;
        const diffDaysAll = diffTimeAll / (1000 * 60 * 60 * 24);

        const date = new Date(year, month, 1);
        const diffTime = date - startDate;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);

        // norm to pos
        var length = (diffDays / diffDaysAll) * arrowLength;

        return lineStart + length;
      }

      function addSVGtoScene2(path, width, height, x, y, z) {
        const loader = new SVGLoader();
        loader.load(
          path,
          function (data) {
            const paths = data.paths;
            const group = new THREE.Group();

            for (let i = 0; i < paths.length; i++) {
              const path = paths[i];
              const material = new THREE.MeshBasicMaterial({
                color: path.color,
                side: THREE.DoubleSide,
                depthWrite: false,
                transparent: true,
              });

              const shapes = path.toShapes(true);

              for (let j = 0; j < shapes.length; j++) {
                const shape = shapes[j];
                const geometry = new THREE.ShapeGeometry(shape);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.multiplyScalar(0.01); // Scale down the SVG
                group.add(mesh);
              }
            }

            // Calculate the bounding box to get SVG size and set the scale according to desired width and height
            group.scale.set(width, height, 1);
            group.position.set(x, y, z);
            scene.add(group);

            // Store the group with its details in a map for later reference
            group.userData = { path, width, height, x, y, z }; // Store original details
            // svgMeshes.push(group); // Assuming svgMeshes is an array visible in this scope
          },
          undefined,
          function (error) {
            console.error("Error loading SVG:", error);
          }
        );
      }

      function addSVGtoScene(path, width, height, x, y, z) {
        const loader = new THREE.TextureLoader();
        loader.load(
          path,
          function (texture) {
            texture.minFilter = THREE.NearestFilter; // Setting minification filter
            texture.magFilter = THREE.NearestFilter; // Setting magnification filter

            const material = new THREE.MeshBasicMaterial({
              map: texture,
              transparent: true, // Useful for SVGs with transparent backgrounds
              side: THREE.DoubleSide, // Render texture on both sides of the mesh
            });
            const geometry = new THREE.PlaneGeometry(width, height);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene.add(mesh);

            // Store the mesh with its details in a map for later reference
            mesh.userData = { path, width, height, x, y, z }; // Store original details
            // svgMeshes.push(mesh); // Assuming svgMeshes is an array visible in this scope
          },
          undefined,
          function (error) {
            console.error("Error loading SVG:", error);
          }
        );
      }

      function updateSVG(mesh, newWidth, newHeight, newX, newY, newZ) {
        // Update geometry size
        mesh.geometry.dispose(); // Dispose of the old geometry first
        mesh.geometry = new THREE.PlaneGeometry(newWidth, newHeight);

        // Update position
        mesh.position.set(newX, newY, newZ);

        // Optionally update the userData if you need to keep track of changes
        mesh.userData.width = newWidth;
        mesh.userData.height = newHeight;
        mesh.userData.x = newX;
        mesh.userData.y = newY;
        mesh.userData.z = newZ;
      }

      function addText(path, month, year) {
        var text = {
          path: path,
          month: month,
          year: year,
        };
        texts.push(text);
      }
    </script>
  </body>
</html>
